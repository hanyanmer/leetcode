### 大根堆

```javascript
//构建堆
let heapify = (arr,n,i)=>{
	let largest = i  //将当前节点进行保存，初始化为根
	let  left = 2*i+1 //定位到当前节点的左边的子节点
	let right = 2*i+2  //当前节点的右边子节点

	if(left<n &&arr[left]>arr[largest]){
		largest = left
	}
	if(right<n && arr[right]>arr[largest]){
		largest = right
	}

	if(largest !==i){
		let swap = arr[i]
		arr[i] = arr[largest]
		arr[largest] = swap

		//和左边或者右边的子节点交换完了，左边或右边的孩子节点又不是大根堆了
		//堆和根节点交换的那个节点 继续和它的左右进行比较
		//有节点调整了，就要重新调用这个函数进行调整
		heapify(arr,n,largest)
	}
}
let sort = (arr)=>{
	let n = arr.length

	//第一次构建大根堆，要从最后一个拥有子节点的节点开始，将该节点连同其子节点进行比较
	//将最大的数交换与该节点，交换后，再依次向前节点进行相同的比较
	//直至构建出大根堆
	//[1,5,3,4,10]
	//第一次i=Math.floor(n/2-1)=1 对应数组中5 此时构建的大根堆[1,10,3,4,5]
	//第二次i-- 此时i=0 对应数组中1 此时构建的大根堆[10,5,3,4,1](调用heapify此时这块是递归的，只要有节点调整了就会继续调用调整)
	for(let i=Math.floor(n/2-1);i>=0;i--){
		heapify(arr,n,i)
	}
	//上面调整后的堆顶永远是最大元素，所以将堆顶和最后一个元素交换
	//第一次交换完最后一个元素为最大值，前n-1个元素重新调整
	//第二次交换完还是和最后一个元素交换，那么后两个元素是从大到小有序的，然后前n-2个元素重新调整
	for(let i=n-1;i>0;i--){

		let temp = arr[0]
		arr[0] = arr[i]
		arr[i] = temp
		//根和最后一个元素交换完成后，前n-1个元素又不是大根堆了 要重新进行调整到大根堆
		heapify(arr,i,0)
	}
}
	let elements = [3, 1, 5, 7, 2, 4, 9, 6, 10, 8];
    console.log('before: ' + elements);
    sort(elements);
    console.log(' after: ' + elements);

```

总结过程：首先从Math.floor(arr.length/2-1)位置开始进行递归方式进行大根堆排序，调整得到大根堆，然后根元素和最后一个元素进行交换，交换后，得到最后一个元素是最大值且有序，前n-1个元素不是大根堆了，此时从根元素进行调整得到大根堆（有一个注意点，这里只要进行交换就要对这个交换的节点重新进行调整，也是一个递归的过程），然后根元素和最后一个元素交换，此时的最后两个元素是有序的，前n-2个元素继续调整为大根堆，以此类推.
还有一个注意点：在调整的函数里面，是直接把数组当成堆了，然后操作的是直接对数组下标操作的



分析：

1.堆排序是原地排序算法

2.堆排序是不稳定的排序算法

3.堆排序包括两个过程：建堆和排序两个操作，建堆过程时间复杂度O(n)，排序过程的时间复杂度是O(nlogn)。

最佳=最差=平均=O(nlogn)

